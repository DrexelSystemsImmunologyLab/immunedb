#!/usr/bin/env python2
import argparse
import getpass
import json
import pymysql
import os
import random
import re
import shlex
import string
import subprocess

import sldb.common.config as config


def _yn_prompt(prompt):
    while True:
        print '{} [Y/N]'.format(prompt),
        v = raw_input().lower()
        if v in ('y', 'n'):
            return v == 'y'

def _get_root_connection(host, user):
    password = getpass.getpass('MySQL password for ({}):'.format(
        user))
    return pymysql.connect(host=host, user=user, password=password,
                           cursorclass=pymysql.cursors.DictCursor)


def _create_user_if_not_exists(conn, host, user, password):
    with conn.cursor() as cursor:
        cursor.execute('SELECT host, user, password from mysql.user WHERE '
                           'user=%s and host=%s', (user, host))
        existing = cursor.fetchone()
        if existing is None:
            cursor.execute('CREATE USER \'{}\'@\'%\' IDENTIFIED BY '
                           '\'{}\''.format(user, password))
            return None
        return existing['password']


def _get_user_pass(conn, host, user, existing_password):
    with conn.cursor() as cursor:
        while True:
            db_pass = getpass.getpass()
            cursor.execute('SELECT PASSWORD(%s) as password', db_pass)
            if cursor.fetchone()['password'] != existing_password:
                print 'Password does not match.'
            else:
                print 'Correct password'
                return db_pass


def _create(main_parser, args):
    if re.search('[^A-Za-z0-9_\-]', args.db_name) is not None:
        main_parser.error('Database name must only contain letters, numbers, '
                          'dashes and underscores.')

    try:
        conn = _get_root_connection(args.db_host, args.admin_user)

        db_user = args.db_user or args.db_name
        if args.db_pass:
            db_pass = getpass.getpass('New MySQL password for ({}):'.format(
                db_user))
        else:
            db_pass = ''.join(
                random.choice(string.ascii_uppercase + string.ascii_lowercase +
                              string.digits) for _ in range(10))


        with conn.cursor() as cursor:
            print 'Creating user "{}"'.format(db_user)
            existing_password = _create_user_if_not_exists(conn, '%', db_user,
                                                           db_pass)
            if existing_password is not None:
                print ('Warning: User {} already exists.  To generate the '
                       'configuration file, you must enter it\'s '
                       'password.').format(db_user)
                db_pass = _get_user_pass(conn, args.db_host, db_user,
                                         existing_password)

            print 'Creating database "{}"'.format(args.db_name)
            cursor.execute('CREATE DATABASE {}'.format(args.db_name))

            cursor.execute(
                'GRANT ALL PRIVILEGES ON {}.* TO \'{}\'@\'%\''.format(
                    args.db_name, db_user))

        config_path = os.path.join(args.config_dir, '{}.json'.format(
            args.db_name))
        print 'Creating config at {}'.format(config_path)
        with open(config_path, 'w+') as fh:
            json.dump({
                'host': args.db_host,
                'database': args.db_name,
                'username': db_user,
                'password': db_pass
            }, fh, sort_keys=True, indent=4, separators=(',', ': '))

        print 'Initializing tables'
        config.init_db(config_path)
        print 'Success!'
    except Exception as e:
        print 'ERROR: {}'.format(e)


def _delete(main_parser, args):
    try:
        with open(args.db_config) as fh:
            db_config = json.load(fh)
        conn = _get_root_connection(db_config['host'], args.admin_user)
        with conn.cursor() as cursor:
            print 'Deleting database {}'.format(db_config['database'])
            cursor.execute('DROP DATABASE `{}`'.format(db_config['database']))
            if args.delete_user:
                print 'Deleting user {}'.format(db_config['username'])
                cursor.execute('DROP USER `{}`'.format(db_config['username']))
    except Exception as e:
        print 'ERROR: {}'.format(e)


def _backup(main_parser, args):
    with open(args.db_config) as fh:
        db_config = json.load(fh)
    with open(args.backup_path, 'w+') as fh:
        cmd = shlex.split(
            'mysqldump -h {} -u {} -p{} {}'.format(db_config['host'],
                                                db_config['username'],
                                                db_config['password'],
                                                db_config['database']))
        proc = subprocess.Popen(cmd, stdout=fh)
        proc.communicate()


def _restore(main_parser, args):
    with open(args.db_config) as fh:
        db_config = json.load(fh)
    with open(args.backup_path, 'r') as fh:
        cmd = shlex.split(
            'mysql -h {} -u {} -p{} {}'.format(db_config['host'],
                                                db_config['username'],
                                                db_config['password'],
                                                db_config['database']))
        proc = subprocess.Popen(cmd, stdin=fh, stdout=subprocess.PIPE,
                                stderr=subprocess.PIPE)
        stdout, stderr = proc.communicate()
        if stderr:
            print 'Warning: {}'.format(stderr)


if __name__ == '__main__':
    main_parser = argparse.ArgumentParser(
        description='Administrative tools for SLDB database instances')
    subparsers = main_parser.add_subparsers(dest='cmd',
                                            help='The task to begin')

    parser = subparsers.add_parser(
        'create', help='Creates a new SLDB database')
    parser.add_argument('admin_user', help='MySQL user with rights to create '
                        'databases')
    parser.add_argument('db_name', help='Database name (letters, numbers, '
                        'dashes and underscores only)')
    parser.add_argument('config_dir', help='The directory in which to store '
                        'the generated configuration file.')
    parser.add_argument('--db-host', default='localhost', help='Hostname or '
                        'IP of the MySQL server. (Default: localhost)')
    parser.add_argument('--db-user', default=None, help='Name of MySQL user '
                        'to generate for the database.  (Default: name of '
                        'database)')
    parser.add_argument('--db-pass', action='store_true', help='Prompt for '
                        'MySQL user password.  (Default: randomly generated)')

    parser = subparsers.add_parser(
        'delete', help='Deletes an existing SLDB database')
    parser.add_argument('admin_user', help='MySQL user with rights to create '
                        'databases')
    parser.add_argument('db_config', help='Path to database config')
    parser.add_argument('--delete-user', action='store_true', help='If '
                        'specified will also delete the user associated '
                        'with the database.  Deleting the user will '
                        'also delete it for other database, so only use if '
                        'you\'re deleting those other databases or the user '
                        'is only associated with this database.')

    parser = subparsers.add_parser('backup', help='Backs up an SLDB database')
    parser.add_argument('db_config', help='Path to database config')
    parser.add_argument('backup_path', help='Path to backup file')

    parser = subparsers.add_parser('restore', help='Restores a backup of an '
                                   'SLDB database')
    parser.add_argument('db_config', help='Path to database config')
    parser.add_argument('backup_path', help='Path to backup file')

    cmds = {
        'create': _create,
        'delete': _delete,
        'backup': _backup,
        'restore': _restore
    }

    args = main_parser.parse_args()
    cmds[args.cmd](main_parser, args)
